```plaintext
{
  'unit': '第78单元：性能与循环优化',
  'questions': [
    {'id':1,'type':'choice','title':'避免重复计算','content':'当循环中多次使用同一表达式结果时应？','options':{'A':'提前计算并缓存','B':'每次重复计算','C':'使用递归替代','D':'编译为 C'},'answer':'A','hints':['缓存结果减少重复开销','局部变量更快'], 'explanation':'将不变计算移出循环或缓存到局部变量可以显著提高性能。','example':'v = expensive(); for x in items: use(v)'},
    {'id':2,'type':'choice','title':'内建函数','content':'在循环内使用内建函数与手写循环相比，通常？','options':{'A':'更快或相当','B':'总是更慢','C':'不可用','D':'编译错误'},'answer':'A','hints':['内建函数用 C 实现通常更快','尽量使用 map/sum 等内建函数'], 'explanation':'内建函数在多数情况下比 Python 级的逐项处理更高效。','example':'sum(lst) vs loop'},
    {'id':3,'type':'choice','title':'甚少重新分配','content':'在循环中频繁扩展列表会导致？','options':{'A':'可能多次重新分配导致性能下降','B':'没有影响','C':'Python 自动优化','D':'内存泄露'},'answer':'A','hints':['预分配或使用生成器可减少 realloc 次数'], 'explanation':'频繁修改可变容器可能触发多次内存重新分配，影响性能。','example':'use append but consider size'},
    {'id':4,'type':'fill','title':'局部变量速度','content':'补全：在循环中引用局部变量比全局变量更快的理由。','input':'(none)','output':'(none)','code':'# 将全局 g 赋给本地变量以加速\ng = 0\nfor i in range(100000):\n    local_g = g\n    x = local_g + i','options':'示例已给出','answer':'1','explanation':'局部变量访问比全局变量快，可减少查找开销。','example':'local = global_var'},
    {'id':5,'type':'fill','title':'使用列表推导','content':'补全：用列表推导替代循环构建列表示例。','input':'1 2 3','output':'2 4 6','code':'lst=list(map(int,input().split()))\nres=[x*2 for x in lst]\nprint(*res)','options':'示例已给出','answer':'1','explanation':'列表推导通常比显式循环更简洁且性能更好。','example':'[f(x) for x in it]'},
    {'id':6,'type':'choice','title':'生成器节省内存','content':'需要逐个处理而无需随机访问序列时应使用？','options':{'A':'生成器','B':'list','C':'tuple','D':'set'},'answer':'A','hints':['生成器按需产出元素','节省内存'], 'explanation':'生成器惰性生成元素，适合流式处理大数据集。','example':'(x for x in range(1000000))'},
    {'id':7,'type':'choice','title':'profile 优先','content':'在优化前应先做什么？','options':{'A':'用 profiler 找瓶颈','B':'直接优化代码','C':'猜测热点优化','D':'增加注释'},'answer':'A','hints':['测量胜于猜测','定位真正耗时部分'], 'explanation':'先用 profiler 找到真正的性能瓶颈再针对性优化。','example':'import cProfile'},
    {'id':8,'type':'choice','title':'避免过早优化','content':'何时应避免过早优化？','options':{'A':'需求未明确或代码尚未正确','B':'任何时候都应优化','C':'永远不优化','D':'只有在 C 中优化'},'answer':'A','hints':['先保证正确，再优化','优化前需有测量结果'], 'explanation':'先实现正确逻辑并有性能数据再优化，可避免无谓工作。','example':'profile then optimize'},
    {'id':9,'type':'fill','title':'用 join 优化','content':'补全：在循环中构造多段文本最后输出的推荐方法。','input':'a b c','output':'a b c','code':'parts=input().split()\nprint(" ".join(parts))','options':'示例已给出','answer':'1','explanation':'收集片段后用 join 一次性输出比频繁 print 更高效。','example':'" ".join(list)'},
    {'id':10,'type':'fill','title':'避免重复方法查找','content':'补全：将对象方法绑定到局部变量以加速循环。','input':'1 2 3','output':'(doubled)','code':'lst=list(map(int,input().split()))\nap=lst.append\nfor x in [1,2,3]:\n    ap(x)\nprint(lst)','options':'示例已给出','answer':'1','explanation':'把方法绑定为局部变量减少属性查找开销。','example':'m = obj.method; for ...: m()'},
    {'id':11,'type':'choice','title':'numpy 使用场景','content':'大量数值运算用原生 Python 循环 vs numpy，推荐？','options':{'A':'numpy 向量化','B':'原生循环总是更好','C':'两者一样','D':'numpy 只适用于图像'},'answer':'A','hints':['numpy 用 C 实现向量化更快','适合大规模数值计算'], 'explanation':'对大规模数值运算，numpy 向量化通常远快于 Python 循环。','example':'import numpy as np'},
    {'id':12,'type':'choice','title':'算法复杂度','content':'对大 N 问题，优化循环更重要还是优化算法更重要？','options':{'A':'优化算法通常更关键','B':'循环优化总能解决问题','C':'微优化优先','D':'都无关紧要'},'answer':'A','hints':['算法级别降阶收益更大','先考虑算法复杂度'], 'explanation':'通常改进算法复杂度带来的性能提升要远超微观循环优化。','example':'从 O(n^2) 到 O(n log n)'},
    {'id':13,'type':'choice','title':'缓存技巧','content':'在循环中复用计算结果时常用的技巧是？','options':{'A':'字典缓存（memoization）','B':'每次都计算','C':'写成注释','D':'换语言'},'answer':'A','hints':['memoization 可降低重复计算开销'], 'explanation':'利用字典缓存中间结果能避免重复的昂贵计算。','example':'cache = {}; if x in cache: ...'},
    {'id':14,'type':'fill','title':'简单并行化','content':'补全：利用 multiprocessing 简单并行化循环任务。','input':'(none)','output':'(none)','code':'from multiprocessing import Pool\ndef f(x): return x*2\nwith Pool() as p:\n    print(p.map(f, [1,2,3]))','options':'示例已给出','answer':'1','explanation':'对 CPU 密集型任务可考虑进程池并行化循环处理。','example':'Pool().map(func, data)'},
    {'id':15,'type':'fill','title':'避免全局锁','content':'补全：多线程中 GIL 对 CPU 密集型循环的影响，推荐？','input':'(none)','output':'(none)','code':'# 对于 CPU 密集型任务建议使用 multiprocessing 而非 threading','options':'示例已给出','answer':'1','explanation':'Python 的 GIL 限制了多线程的 CPU 并行，CPU 密集型推荐多进程。','example':'use multiprocessing'}
  ]
}

```

*** End Patch