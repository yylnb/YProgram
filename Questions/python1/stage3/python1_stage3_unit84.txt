```plaintext
{
  'unit': '第84单元：并行与并发基础（循环角度）',
  'questions': [
    {'id':1,'type':'choice','title':'线程 vs 进程','content':'对于 CPU 密集型循环任务通常推荐？','options':{'A':'多进程','B':'多线程','C':'单线程就够','D':'协程'},'answer':'A','hints':['GIL 限制多线程 CPU 并行','多进程可并行利用多核'], 'explanation':'Python 的 GIL 导致多线程在 CPU 密集型任务中受限，多进程更能利用多核。','example':'multiprocessing.Pool'},
    {'id':2,'type':'choice','title':'协程优势','content':'协程（asyncio）在循环处理中适合？','options':{'A':'IO 密集型并发任务','B':'CPU 密集型计算','C':'无法并发','D':'替代多进程'},'answer':'A','hints':['协程适合大量 IO 等待的场景'], 'explanation':'asyncio 在大量 IO 等待时能高效调度协程，减少线程/进程开销。','example':'await asyncio.sleep(1)'},
    {'id':3,'type':'choice','title':'线程安全','content':'当多个线程在循环中修改同一变量时应使用？','options':{'A':'锁（Lock）','B':'不需任何保护','C':'只用 print','D':'assert'},'answer':'A','hints':['使用锁保护共享资源避免竞态'], 'explanation':'对共享可变状态需要使用同步原语如 Lock 以避免竞态条件。','example':'with lock: counter += 1'},
    {'id':4,'type':'fill','title':'进程池 map','content':'补全：用进程池并行处理并返回结果。','input':'1 2 3','output':'[2,4,6]','code':'from multiprocessing import Pool\ndef f(x): return x*2\nwith Pool() as p:\n    print(p.map(f, list(map(int,input().split()))))','options':'示例已给出','answer':'1','explanation':'Pool.map 可并行运行函数并收集结果。','example':'Pool().map(func, data)'},
    {'id':5,'type':'fill','title':'协程示例','content':'补全：简单 asyncio 并发运行两任务。','input':'(none)','output':'(none)','code':'import asyncio\nasync def t(n):\n    await asyncio.sleep(0)\n    return n\nprint(asyncio.run(asyncio.gather(t(1), t(2))))','options':'示例已给出','answer':'1','explanation':'asyncio.gather 可并发运行协程并收集结果。','example':'asyncio.run(gather(...))'},
    {'id':6,'type':'choice','title':'I/O 密集型','content':'大量网络请求循环中优先使用？','options':{'A':'异步/线程池','B':'多进程','C':'纯阻塞调用','D':'不建议并发'},'answer':'A','hints':['IO 密集型适合协程或线程池并发'], 'explanation':'网络 IO 等待时间长，使用异步或线程池能提高吞吐量。','example':'use aiohttp or ThreadPoolExecutor'},
    {'id':7,'type':'choice','title':'共享数据设计','content':'并发循环中共享数据最安全的模式是？','options':{'A':'使用队列传递数据','B':'直接共享全局变量','C':'每线程写同一列表','D':'不管理'},'answer':'A','hints':['队列提供线程/进程安全的数据交换'], 'explanation':'使用 Queue 或 multiprocessing.Queue 在并发环境中安全传递数据。','example':'from queue import Queue'},
    {'id':8,'type':'choice','title':'进程开销','content':'相比线程，进程的劣势通常是？','options':{'A':'启动开销与内存开销更大','B':'更快启动','C':'更低内存','D':'无差别'},'answer':'A','hints':['进程需要复制或独立内存空间'], 'explanation':'进程隔离带来更高的资源开销，但提供更好的独立性与 CPU 并行。','example':'multiprocessing vs threading'},
    {'id':9,'type':'fill','title':'用线程池','content':'补全：用 ThreadPoolExecutor 并发执行函数并打印结果。','input':'1 2 3','output':'(results)','code':'from concurrent.futures import ThreadPoolExecutor\ndef f(x): return x*2\nwith ThreadPoolExecutor() as e:\n    print(list(e.map(f, map(int,input().split()))))','options':'示例已给出','answer':'1','explanation':'ThreadPoolExecutor.map 可并发执行并返回结果生成器。','example':'executor.map(fn, data)'},
    {'id':10,'type':'fill','title':'避免共享状态','content':'补全：尽量避免在线程间共享可变数据，示例用队列传递任务。','input':'(none)','output':'(none)','code':'from queue import Queue\nq=Queue()\nq.put(1)\nprint(q.get())','options':'示例已给出','answer':'1','explanation':'队列提供线程安全的生产/消费模型，减少共享状态问题。','example':'q.put(item)'}
    ,{'id':11,'type':'choice','title':'GIL 影响','content':'GIL 对多线程的影响是？','options':{'A':'限制 Python 线程的 CPU 并行性','B':'完全无影响','C':'使多线程更快','D':'只影响 I/O'},'answer':'A','hints':['GIL 主要影响 CPU 密集型代码'], 'explanation':'GIL 导致 Python 多线程在 CPU 密集型任务上不能同时利用多核。','example':'use multiprocessing for CPU work'},
    {'id':12,'type':'choice','title':'协程与回调','content':'async/await 与回调风格相比的优势？','options':{'A':'更直观的顺序代码风格','B':'更复杂','C':'性能更差','D':'不可组合'},'answer':'A','hints':['async/await 写法更接近同步逻辑'], 'explanation':'async/await 提供更直观的异步控制流，避免复杂回调地狱。','example':'async def main():'},
    {'id':13,'type':'choice','title':'并发调试','content':'并发程序调试困难，常用手段是？','options':{'A':'添加日志与重现最小场景','B':'不调试','C':'使用 print 取代日志','D':'仅重启服务'},'answer':'A','hints':['日志和可重复的最小重现有助定位并发问题'], 'explanation':'通过详尽日志并构建可重复的测试场景有助调试并发问题。','example':'add contextual logs'},
    {'id':14,'type':'fill','title':'进程间通信','content':'补全：使用 multiprocessing.Queue 在父进程获取子进程结果。','input':'(none)','output':'(none)','code':'from multiprocessing import Process, Queue\nq=Queue()\ndef f(q): q.put(1)\np=Process(target=f,args=(q,))\np.start()\nprint(q.get())\np.join()','options':'示例已给出','answer':'1','explanation':'multiprocessing.Queue 用于进程间安全通信。','example':'q.put(x) and q.get()'},
    {'id':15,'type':'fill','title':'并发安全写文件','content':'补全：多个线程写同一文件时应如何保证安全？','input':'(none)','output':'(none)','code':'from threading import Lock\nlock=Lock()\nwith open("out.txt","a") as f:\n    with lock:\n        f.write("data\n")','options':'示例已给出','answer':'1','explanation':'使用锁保护写文件的临界区以避免数据混杂。','example':'with lock: f.write(...)'}
  ]
}

```

*** End Patch