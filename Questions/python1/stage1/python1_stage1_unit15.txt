[
  {
    'id': 1,
    'type': 'choice',
    'title': '步长为负的含义',
    'content': '若 s = "abcdefg"，表达式 s[5:1:-1] 会得到什么？',
    'options': {
      'A': '"fedc"',
      'B': '"feds"',
      'C': '"fed"',
      'D': '"gfed"'
    },
    'answer': 'C',
    'hints': [
      '步长为 -1 表示从右向左取字符。',
      '结束索引 1 不包含在结果里。',
      '起点 5 对应字符 "f"。'
    ],
    'explanation': 's[5:1:-1] 会从索引 5(f) 向左取到索引 2(d)（因为 1 不包含），结果为 "fed"。',
    'example': '例如 "abcdefg"[5:1:-1] → "fed"'
  },

  {
    'id': 2,
    'type': 'choice',
    'title': '步长与包含关系',
    'content': '表达式 s[::3] 对字符串 s = "0123456789" 会返回什么？',
    'options': {
      'A': '"0369"',
      'B': '"048"',
      'C': '"0123456789"',
      'D': '"0369?"'
    },
    'answer': 'A',
    'hints': [
      '步长 3 表示每隔两个字符取一个。',
      '从索引 0 开始（默认）取：0,3,6,9。',
      '结果是这些索引对应的字符组合。'
    ],
    'explanation': 's[::3] 取索引 0,3,6,9 对应 "0","3","6","9" → "0369"。',
    'example': '例如 "abcdef"[::2] → "ace"'
  },

  {
    'id': 3,
    'type': 'choice',
    'title': 'slice 对象用途',
    'content': '下列哪一项关于 slice(1,5,2) 的说法正确？',
    'options': {
      'A': '它直接对字符串进行切片并返回结果',
      'B': '它是一个表示切片参数的对象，可用于 s[slice(...)]',
      'C': 'slice 只能用于列表，不能用于字符串',
      'D': 'slice 会修改原始序列'
    },
    'answer': 'B',
    'hints': [
      'slice 是一个描述切片参数的内建类型。',
      '它本身不直接返回子串，需作为索引参数传入序列。',
      'slice 既可用于字符串也可用于列表。'
    ],
    'explanation': 'slice(1,5,2) 返回一个切片对象，可在 s[slice(1,5,2)] 中使用。',
    'example': 's = "abcdef"; s[slice(1,5,2)] → "bd"'
  },

  {
    'id': 4,
    'type': 'fill',
    'title': '用 slice 对象切片',
    'content': '使用 slice 对象取得 s 的 "bdf"（s = "abcdefg"）。',
    'input': 's = "abcdefg"',
    'output': 'bdf',
    'code': 'sl = slice(___)\nprint(s[sl])',
    'options': '1,6,2,1,6,2,1,5,2, 0,7,3',
    'answer': '1,3,2',
    'explanation': '需要 slice(1,6,2)，即从索引1到5（6 不包含），步长2 → "bdf"。',
    'example': 'slice(1,6,2) 可在 s[slice(1,6,2)] 中使用'
  },

  {
    'id': 5,
    'type': 'fill',
    'title': '结合 len 计算后半段',
    'content': '补全切片，取得字符串后半段（若长度为奇数，包含中位），例如 s="ABCDE" → "CDE"。',
    'input': 's = "ABCDE"',
    'output': 'CDE',
    'code': 'half = s[len(s)___]\nprint(half)',
    'options': '//2:, //2, /2:, //2-1, -len(s)//2:, :len(s)//2, len(s)//2:',
    'answer': '7',
    'explanation': 'len(s)//2 计算中间索引（整数除法），从该索引到末尾为后半段，故 s[len(s)//2:]。',
    'example': '若 s="ABCD" len//2=2 → s[2:]="CD"'
  },

  {
    'id': 6,
    'type': 'choice',
    'title': '切片与原字符串不可变性',
    'content': '关于对字符串切片赋值（如 s[1:3] = "X"），以下哪项正确？',
    'options': {
      'A': '可行，字符串会被修改',
      'B': '不可行，会抛出 TypeError，因为字符串是不可变的',
      'C': '只有在 Python2 中可行',
      'D': '会把切片结果当作列表赋值'
    },
    'answer': 'B',
    'hints': [
      '字符串在 Python 中是不可变类型（immutable）。',
      '不能对其进行原地修改。',
      '尝试赋值会触发异常。'
    ],
    'explanation': '字符串不可变，尝试对切片赋值会抛出 TypeError。',
    'example': 's = "abc"; s[1] = "x" 会报错'
  },

  {
    'id': 7,
    'type': 'choice',
    'title': '省略参数与默认行为',
    'content': 's[:: -2] 与 s[::-2] 有何区别？',
    'options': {
      'A': '它们是等价的，都表示反向每隔一个字符取一个',
      'B': 's[::-2] 会报错',
      'C': 's[:: -2] 中的空格会导致语法错误',
      'D': '前者从左到右，后者从右到左'
    },
    'answer': 'A',
    'hints': [
      '切片中多余的空格不会影响语法',
      '负步长表示反向',
      '两者表达相同含义'
    ],
    'explanation': 's[::-2] 与 s[:: -2] 等价，都会从末尾开始每隔一个字符取一个。',
    'example': '"abcdef"[::-2] → "fdb"'
  },

  {
    'id': 8,
    'type': 'choice',
    'title': '复杂切片的输出长度',
    'content': '若 s="0123456789"，s[1:9:3] 的长度是多少？',
    'options': {
      'A': '2',
      'B': '3',
      'C': '4',
      'D': '5'
    },
    'answer': 'B',
    'hints': [
      '索引取 1,4,7。',
      '这些索引都小于 9 且按步长 3 取。',
      '计算元素个数。'
    ],
    'explanation': '取索引 1、4、7 共 3 个字符。',
    'example': 'len("0123456789"[1:9:3]) → 3'
  },

  {
    'id': 9,
    'type': 'fill',
    'title': '从字符串中提取扩展模式',
    'content': '从 s="ab-cd-ef-gh" 提取每段的首字母，得到 "aceg"。',
    'input': 's = "ab-cd-ef-gh"',
    'output': 'aceg',
    'code': 'parts = s.split("-")\njoined = "".join(p[0] for p in parts)\nprint(joined)\n# 请改用切片直接取得结果：\nprint(s[___])',
    'options': '0::3, 0::4, 1::3, ::3, ::4, 2::3, 0::2',
    'answer': '4',
    'explanation': '原字符串格式为 "ab-cd-ef-gh"，每段长度为2加一个连接符，总的规律是每隔 3 个字符取一个（索引0,3,6,9）→ s[::3] → "aceg"。',
    'example': '"ab-cd-ef-gh"[::3] → "aceg"'
  },

  {
    'id': 10,
    'type': 'fill',
    'title': '利用负步长提取单词字符',
    'content': '给定 s="hello_world"，用切片反向取得 "dlrow"（注意小写），并补全代码。',
    'input': 's = "hello_world"',
    'output': 'dlrow',
    'code': 'print(s[___])',
    'options': '6:11:-1, 10:5:-1, 10:4:-1, -1:-6:-1, 5:0:-1, -1:-5:-1',
    'answer': '2',
    'explanation': '要取得 "dlrow"（对应原字符串索引 10->6），切片写成 s[10:5:-1]（10 包含，5 不包含）。',
    'example': '"hello_world"[10:5:-1] → "dlrow"'
  },

  {
    'id': 11,
    'type': 'choice',
    'title': '切片与内存/性能提示',
    'content': '关于对大字符串做切片操作，哪项说法更准确？',
    'options': {
      'A': '切片总是原地修改字符串，不分配新内存',
      'B': '切片返回新字符串，可能会分配新的内存',
      'C': '切片会共享原字符串底层内存，不发生复制',
      'D': '对短字符串切片会复制，对长字符串不会'
    },
    'answer': 'B',
    'hints': [
      '字符串是不可变对象，切片返回新对象。',
      '通常会发生内存分配以保存子串。',
      '并非原地修改或共享底层可变内存。'
    ],
    'explanation': '字符串切片会创建并返回一个新的字符串对象，通常需要分配内存来保存结果。',
    'example': 's2 = s[:1000] 会创建新的字符串 s2'
  },

  {
    'id': 12,
    'type': 'choice',
    'title': '负步长的边界行为',
    'content': 's = "abcd"，表达式 s[3:0:-1] 的结果是什么？',
    'options': {
      'A': '"dcba"',
      'B': '"dcb"',
      'C': '"cba"',
      'D': '""'
    },
    'answer': 'B',
    'hints': [
      '起点 3 是 "d"。',
      '结束索引 0 不包含在结果中。',
      '步长 -1 会向左取。'
    ],
    'explanation': 's[3:0:-1] 取索引 3(d)、2(c)、1(b) → "dcb"。',
    'example': '"abcd"[3:0:-1] → "dcb"'
  },

  {
    'id': 13,
    'type': 'choice',
    'title': '切片与复制完整序列',
    'content': '如何用切片创建字符串 s 的完整拷贝？',
    'options': {
      'A': 's.copy()',
      'B': 's[:] ',
      'C': 's[0:len(s)-1]',
      'D': 's[1:]'
    },
    'answer': 'B',
    'hints': [
      '复制整个序列的经典写法是什么？',
      '使用起始和结束都省略的切片。',
      '这种方式会得到与原字符串相同的新对象。'
    ],
    'explanation': 's[:] 会返回包含全部字符的新字符串（浅复制效果）。',
    'example': 's2 = s[:]; s2 == s'
  },

  {
    'id': 14,
    'type': 'fill',
    'title': '组合切片与步长',
    'content': '给定 s="abcdefghij"，补全切片使其返回 "bdfhj"（从索引1开始每隔2取直到末尾）。',
    'input': 's = "abcdefghij"',
    'output': 'bdfhj',
    'code': 'print(s[___])',
    'options': '1::2, 1:10:2, 1:11:2, 1:9:2, 2::2, ::2',
    'answer': '2',
    'explanation': '要从索引1取到末尾并步长为2，写成 s[1:10:2]（10 为 len(s)），选项 1::2 也可，但题中更严谨指定结束索引为 10，因此选择 1:10:2。',
    'example': '亦可写成 s[1::2]'
  },

  {
    'id': 15,
    'type': 'fill',
    'title': '多重切片思想演练',
    'content': '将字符串先取出中间段再反转：先从 s="0123456789" 取得 "3456"，然后反转得到 "6543"。请补全两步操作。',
    'input': 's = "0123456789"',
    'output': '6543',
    'code': 'mid = s[___]\nprint(mid[___])',
    'options': '3:7, 3:6, 2:6, -1:-5:-1, ::-1, ::1, ::-1, 3:7, 3:7, 3:7',
    'answer': '1,4',
    'explanation': '先用 s[3:7] 获取索引 3,4,5,6 对应 "3456"，然后用 [::-1] 反转得到 "6543"（所以 mid[::-1]）。',
    'example': 'mid = s[3:7]\nprint(mid[::-1])  # 6543'
  }
]