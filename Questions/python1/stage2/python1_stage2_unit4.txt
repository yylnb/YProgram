```plaintext
{
  'unit': '第4单元：多个 elif',
  'questions': [

    {
      'id': 1,
      'type': 'choice',
      'title': '多个 elif 的用处',
      'content': '为何会使用多个 elif？',
      'options': {'A':'处理多个互斥情况','B':'提高程序运行速度','C':'替代循环','D':'定义常量'},
      'answer': 'A',
      'hints': ['用于互斥分支', '便于分段处理', '比一堆 if 更语义化'],
      'explanation': '多个 elif 常用于处理多个互斥条件的判断。',
      'example': 'if ...\nelif ...\nelif ...\nelse: ...'
    },

    {
      'id': 2,
      'type': 'choice',
      'title': '顺序覆盖问题',
      'content': '哪个会导致后续分支无法触发？',
      'options': {'A':'把更宽泛条件放在前面','B':'把更具体条件放在前面','C':'条件互不相交','D':'增加 else'},
      'answer': 'A',
      'hints': ['宽泛条件可能先匹配', '后面的条件被挡住', '按优先级安排条件'],
      'explanation': '应把更具体的条件放在前面以免被更宽泛的条件捕获。',
      'example': 'if x>0 ... elif x>5 ... 这会出问题'
    },

    {
      'id': 3,
      'type': 'choice',
      'title': 'elif 与互斥性',
      'content': '使用 elif 能保证什么？',
      'options': {'A':'所有分支都执行','B':'只执行第一个匹配分支','C':'随机执行一个分支','D':'不执行任何分支'},
      'answer': 'B',
      'hints': ['互斥逻辑', '按顺序匹配', '第一个为真则终止链'],
      'explanation': 'elif 链保证只执行第一个满足条件的分支。',
      'example': 'if a: ...\nelif b: ...\nelse: ...'
    },

    {
      'id': 4,
      'type': 'fill',
      'title': '按区间分配',
      'content': '补全分支输出 Low/Med/High。',
      'input': 'x=50',
      'output': 'Med',
      'code': 'x=50\nif x < 30:\n    print("Low")\nelif x < 70:\n    print(___)\nelse:\n    print("High")',
      'options': '"Low","Med","High","OK"',
      'answer': '"Med"',
      'explanation': '50 在 30–69 区间，输出 Med。',
      'example': '区间判断常用 elif 实现。'
    },

    {
      'id': 5,
      'type': 'fill',
      'title': '覆盖测试',
      'content': '将更具体条件放前以修复逻辑。',
      'input': '',
      'output': '',
      'code': 'x=8\nif x>0:\n    print(">0")\nelif x>5:\n    print(">5")',
      'options': '将 x>5 放前, 删除第二行, 改为 while, 改为函数',
      'answer': '将 x>5 放前',
      'explanation': '将更具体的 x>5 放在前面，才能正确匹配。',
      'example': 'if x>5:\n    ...\nelif x>0:\n    ...'
    },

    {
      'id': 6,
      'type': 'choice',
      'title': '多个 elif 的性能',
      'content': '大量 elif 会导致？',
      'options': {'A':'必然变慢很多','B':'在最坏情况遍历多次条件','C':'引发语法错误','D':'内存泄露'},
      'answer': 'B',
      'hints': ['顺序影响执行次数', '最好把常见情况放前', '可用映射表替代大量分支'],
      'explanation': '大量 elif 在最坏情况下会评估多次条件，应优化顺序或使用数据结构替代。',
      'example': '使用 dict mapping 处理众多平行分支。'
    },

    {
      'id': 7,
      'type': 'choice',
      'title': '调试 elif 链',
      'content': '调试复杂 elif 链时最好做什么？',
      'options': {'A':'添加日志打印每个条件','B':'随机修改顺序','C':'删除所有 elif','D':'增加全局变量'},
      'answer': 'A',
      'hints': ['日志能帮助定位匹配分支', '逐步验证条件', '不要盲改顺序'],
      'explanation': '在每个分支处打印或记录可以帮助调试分支匹配问题。',
      'example': 'print("checking x>5") before condition'
    },

    {
      'id': 8,
      'type': 'choice',
      'title': 'elif 的替代方案',
      'content': '哪种情况建议使用字典映射而非大量 elif？',
      'options': {'A':'基于数值区间', 'B':'基于离散键映射相应函数', 'C':'需要复杂布尔表达式', 'D':'需要嵌套循环'},
      'answer': 'B',
      'hints': ['离散键适合映射', '函数映射可提高可读性', '区间判断仍用 elif'],
      'explanation': '当条件基于离散值时，使用 dict 映射到处理函数更清晰且容易扩展。',
      'example': 'actions = {1: f1, 2: f2}; actions.get(cmd, default)()'
    },

    {
      'id': 9,
      'type': 'fill',
      'title': '分支重构',
      'content': '将以下代码重构为更优顺序。',
      'input': '',
      'output': '',
      'code': 'x=100\nif x>0:\n    print("pos")\nelif x>50:\n    print(">50")',
      'options': '先判断 x>50 再判断 x>0, 保持不变, 删除第一条, 改为 while',
      'answer': '先判断 x>50 再判断 x>0',
      'explanation': '应先判断 100 是否 >50，然后再判断 >0，避免被更宽泛条件挡住。',
      'example': 'if x>50:\n    ...\nelif x>0:\n    ...'
    },

    {
      'id': 10,
      'type': 'fill',
      'title': '实践：等级判断',
      'content': '补全：>=90 A, >=80 B, >=70 C, else D。',
      'input': 'score=77',
      'output': 'C',
      'code': 'score=77\nif score >= 90:\n    print("A")\nelif score >= 80:\n    print("B")\nelif score >= 70:\n    print(___)\nelse:\n    print("D")',
      'options': '"A","B","C","D"',
      'answer': '"C"',
      'explanation': '77 属于 70–79，应输出 C。',
      'example': 'elif 常用于评分分档。'
    },

    {
      'id': 11,
      'type': 'choice',
      'title': '顺序不当的后果',
      'content': '若把最常见条件放到最后会怎样？',
      'options': {'A':'可提高效率','B':'可能每次都要遍历所有条件','C':'无影响','D':'语法错误'},
      'answer': 'B',
      'hints': ['顺序决定匹配次数', '常见情况应优先处理', '性能受影响'],
      'explanation': '将最常见情况放后会导致在多数情况下遍历更多分支，影响性能。',
      'example': '把常见情况放在前面减少判断次数'
    },

    {
      'id': 12,
      'type': 'choice',
      'title': '边界条件处理',
      'content': '处理数值分段时应注意什么？',
      'options': {'A':'边界是否包含左闭右开','B':'顺序可以随意', 'C':'忽略等号', 'D':'用字符串比较'},
      'answer': 'A',
      'hints': ['注意 >= 与 > 的使用', '边界重复会造成歧义', '写清楚包含端点'],
      'explanation': '应明确区间端点（包含或不包含）以避免覆盖或漏判。',
      'example': 'if x>=70 and x<80: ... 或使用 elif x>=70:...'
    },

    {
      'id': 13,
      'type': 'choice',
      'title': '测试大量分支',
      'content': '如何对大量 elif 分支进行自动化测试？',
      'options': {'A':'手工测试每个分支','B':'编写单元测试覆盖每个条件','C':'不需要测试','D':'只测试边界'},
      'answer': 'B',
      'hints': ['单元测试可覆盖所有条件', '自动化测试减少人为遗漏', '确保边界也被测试'],
      'explanation': '为每个分支写单元测试能保证分支逻辑正确并在修改后保持稳定。',
      'example': 'pytest 编写多个用例覆盖所有分支'
    },

    {
      'id': 14,
      'type': 'fill',
      'title': '实际演练：奖金分配',
      'content': '补全分支：>1000 大奖, >500 较大, else 普通。',
      'input': 'amount=600',
      'output': '较大',
      'code': 'amount=600\nif amount > 1000:\n    print("大奖")\nelif amount > 500:\n    print(___)\nelse:\n    print("普通")',
      'options': '"大奖","较大","普通","无"',
      'answer': '"较大"',
      'explanation': '600 在 500–1000，应输出 较大。',
      'example': 'elif 常用于金额分级。'
    },

    {
      'id': 15,
      'type': 'fill',
      'title': '练习：星期映射',
      'content': '使用 elif 根据数字输出工作日/周末',
      'input': 'd=6',
      'output': 'Weekend',
      'code': 'd=6\nif d in [1,2,3,4,5]:\n    print("Workday")\nelif d in [6,7]:\n    print(___)\nelse:\n    print("Invalid")',
      'options': '"Weekend","Workday","Invalid","Holiday"',
      'answer': '"Weekend"',
      'explanation': '6,7 为周末。',
      'example': 'elif 可用于集合匹配。'
    }

  ]
}
```
