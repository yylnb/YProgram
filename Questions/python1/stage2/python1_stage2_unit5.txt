```plaintext
{
  'unit': '第5单元：嵌套 if（基础）',
  'questions': [

    {
      'id': 1,
      'type': 'choice',
      'title': '什么是嵌套 if',
      'content': '下面哪个描述最贴切？',
      'options': {'A':'在 if 内再写一个 if','B':'在循环外写 if','C':'用 if 定义函数','D':'在 if 中使用 return'},
      'answer': 'A',
      'hints': ['嵌套即层级结构', '注意缩进', '合法且常用'],
      'explanation': '嵌套 if 是在一个 if 的代码块内部再写另一个 if，以实现更细粒度的分支。',
      'example': 'if a:\n    if b:\n        ...'
    },

    {
      'id': 2,
      'type': 'choice',
      'title': '缩进层级',
      'content': '嵌套 if 需要注意什么？',
      'options': {'A':'层级缩进正确','B':'缩进无关紧要','C':'只能缩进两个级别','D':'内部 if 必须有 elif'},
      'answer': 'A',
      'hints': ['缩进决定所属块', '错误缩进会改变逻辑或触发语法错误', '保持一致的缩进风格'],
      'explanation': '嵌套结构依赖缩进来区分不同层级，保持正确缩进是关键。',
      'example': 'if a:\n    if b:\n        print("ok")'
    },

    {
      'id': 3,
      'type': 'choice',
      'title': '嵌套示例用途',
      'content': '嵌套 if 常用于下列哪种场景？',
      'options': {'A':'逐级校验复杂条件','B':'替代函数','C':'替代字典','D':'增加循环次数'},
      'answer': 'A',
      'hints': ['逐步校验更容易理解', '适合分层次检查输入', '避免一次写复杂条件'],
      'explanation': '嵌套 if 有助于分层验证不同条件，便于分步处理和早期返回。',
      'example': 'if logged_in:\n    if is_admin:\n        show_admin()'
    },

    {
      'id': 4,
      'type': 'fill',
      'title': '嵌套判断示例',
      'content': '补全：当用户已登录且为管理员时打印 Admin。',
      'input': 'logged=True; is_admin=True',
      'output': 'Admin',
      'code': 'logged = True\nis_admin = True\nif logged:\n    if is_admin:\n        print(___)',
      'options': '"Admin","User","Guest","None"',
      'answer': '"Admin"',
      'explanation': '内层 if 用于判断管理员身份并输出 Admin。',
      'example': 'if logged:\n    if premium:\n        show_premium()'
    },

    {
      'id': 5,
      'type': 'fill',
      'title': '缩进错误修复',
      'content': '修复缩进使嵌套 if 合法。',
      'input': '',
      'output': '',
      'code': 'if a:\nif b:\n    print("ok")',
      'options': '给第二行缩进, 删除一行, 加 else, 改为 while',
      'answer': '给第二行缩进',
      'explanation': '内层 if 需要缩进以在外层 if 的代码块内。',
      'example': 'if a:\n    if b:\n        print("ok")'
    },

    {
      'id': 6,
      'type': 'choice',
      'title': '多层嵌套问题',
      'content': '过深的嵌套可能导致？',
      'options': {'A':'更好可读','B':'降低可读性并难以维护','C':'提高性能','D':'自动优化'},
      'answer': 'B',
      'hints': ['深嵌套难以理解', '考虑重构为函数', '遵守单一职责原则'],
      'explanation': '过深嵌套会降低可读性并增加维护成本，建议提炼函数或简化逻辑。',
      'example': '把复杂条件拆成多个小函数'
    },

    {
      'id': 7,
      'type': 'choice',
      'title': '嵌套与短路',
      'content': '嵌套 if 与逻辑短路相比的区别是什么？',
      'options': {'A':'嵌套会短路','B':'逻辑短路不会创建新的缩进层','C':'两者等价','D':'嵌套更快'},
      'answer': 'B',
      'hints': ['短路是表达式求值特性', '嵌套是语句结构', '二者用途不同'],
      'explanation': '逻辑短路发生在表达式中，而嵌套 if 是语句结构，短路不改变代码块层级。',
      'example': 'if a and b: ... 与 if a:\n    if b: ... 区别在形式但可能在副作用上有差别'
    },

    {
      'id': 8,
      'type': 'choice',
      'title': '避免嵌套策略',
      'content': '若要减少嵌套层级，推荐做法是？',
      'options': {'A':'提炼函数','B':'增加更多嵌套','C':'使用全局变量','D':'在条件中硬编码常量'},
      'answer': 'A',
      'hints': ['提炼函数能抽离职责', '重构后更易测试', '保持函数短小'],
      'explanation': '把内部逻辑提炼为函数是常见的减少嵌套、提高可读性的做法。',
      'example': 'def check():\n    if a: ...\nif check(): ...'
    },

    {
      'id': 9,
      'type': 'fill',
      'title': '多层嵌套判断',
      'content': '补全行使其只在所有条件都满足时打印 Yes。',
      'input': 'a=True;b=True;c=True',
      'output': 'Yes',
      'code': 'a=True\nb=True\nc=True\nif a:\n    if b:\n        if c:\n            print(___)',
      'options': '"Yes","No","OK","None"',
      'answer': '"Yes"',
      'explanation': '只有当 a,b,c 都为 True 才打印 Yes。',
      'example': '逐级检查多个权限标志。'
    },

    {
      'id': 10,
      'type': 'fill',
      'title': '缩进演练',
      'content': '将缺少缩进的代码修复为嵌套 if。',
      'input': '',
      'output': '',
      'code': 'if x>0:\nif y>0:\n    print("both")',
      'options': '给第二行缩进, 删除第二行, 改为 elif, 改为 while',
      'answer': '给第二行缩进',
      'explanation': '内层 if 需要缩进以表示属于外层分支。',
      'example': 'if x>0:\n    if y>0:\n        print("both")'
    },

    {
      'id': 11,
      'type': 'choice',
      'title': '嵌套与早期返回',
      'content': '在函数中遇到深层嵌套时常见做法是？',
      'options': {'A':'继续嵌套','B':'使用早期返回减少嵌套','C':'用全局变量逃逸','D':'用异常控制流程'},
      'answer': 'B',
      'hints': ['早期返回能减少嵌套层级', '提高可读性', '避免大量缩进'],
      'explanation': '通过在不满足条件时立即返回，可以减少嵌套层数，使代码更平坦更易读。',
      'example': 'if not valid: return\n# 之后逻辑不需再缩进'
    },

    {
      'id': 12,
      'type': 'choice',
      'title': '嵌套中的变量作用域',
      'content': '内层 if 创建的新变量在外层是否可见？',
      'options': {'A':'不可见','B':'可见（同一函数内）','C':'仅在 if 内可见','D':'创建新作用域'},
      'answer': 'B',
      'hints': ['Python 仅函数/类/模块创建作用域', 'if/for 不创建新作用域', '内层变量可在外层访问'],
      'explanation': 'if 语句不会创建新的作用域，内层定义的变量在同一函数内可见。',
      'example': 'if True:\n    x=1\nprint(x)  # 可见'
    },

    {
      'id': 13,
      'type': 'choice',
      'title': '嵌套与可测试性',
      'content': '为何深嵌套会降低可测试性？',
      'options': {'A':'更难覆盖所有路径','B':'提高性能','C':'减少代码行','D':'增强可读性'},
      'answer': 'A',
      'hints': ['路径数随嵌套指数增长', '难以编写全面测试用例', '建议重构'],
      'explanation': '嵌套会增加可能的执行路径，导致测试需要覆盖更多组合，降低可测试性。',
      'example': '把复杂逻辑拆成小函数并分别测试'
    },

    {
      'id': 14,
      'type': 'fill',
      'title': '练习：权限判断',
      'content': '补全：登陆 且 (管理员或 VIP) 时允许。',
      'input': 'logged=True; is_admin=False; is_vip=True',
      'output': 'Allowed',
      'code': 'logged=True\nis_admin=False\nis_vip=True\nif logged:\n    if is_admin or is_vip:\n        print(___)',
      'options': '"Allowed","Denied","Login","None"',
      'answer': '"Allowed"',
      'explanation': '只要 is_admin 或 is_vip 为真且已登录即允许。',
      'example': '嵌套和逻辑组合常用于权限判断。'
    },

    {
      'id': 15,
      'type': 'fill',
      'title': '实战：复合条件',
      'content': '补全：需要满足两层条件才通过。',
      'input': 'a=True; b=False',
      'output': '',
      'code': 'a=True\nb=False\nif a:\n    if b:\n        print("Pass")\n    else:\n        print(___)',
      'options': '"Fail","Pass","OK","None"',
      'answer': '"Fail"',
      'explanation': 'a 为真但 b 为假，内层 else 应输出 Fail。',
      'example': '分层判断结果处理常见于表单校验。'
    }

  ]
}
```
