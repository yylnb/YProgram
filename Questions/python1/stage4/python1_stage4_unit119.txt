```plaintext
{
  'unit': '第119单元：缓存与 Memoization',
  'questions': [

    {
      'id': 1,
      'type': 'choice',
      'title': '缓存的目标',
      'content': '使用缓存（caching）的主要目的是？',
      'options': {
        'A': '减少重复计算或重复 I/O，从而提高响应速度',
        'B': '增加内存占用无收益',
        'C': '确保数据最新',
        'D': '替代数据库'
      },
      'answer': 'A',
      'hints': [
        '提示1': 缓存保存之前计算的结果',
        '提示2': 重复请求命中缓存可节省时间',
        '提示3': 需权衡一致性与空间'
      ],
      'explanation': '缓存通过保存昂贵操作的结果提高性能，但需处理缓存失效与一致性问题。',
      'example': ''
    },

    {
      'id': 2,
      'type': 'choice',
      'title': 'lru_cache',
      'content': 'Python 的 functools.lru_cache 默认按什么策略回收？',
      'options': {
        'A': '最近最少使用（LRU）',
        'B': '随机',
        'C': '先进先出（FIFO）',
        'D': '最长时间未访问'
      },
      'answer': 'A',
      'hints': [
        '提示1': lru_cache 意为最近最少使用缓存',
        '提示2': 容量满时驱逐 LRU 条目',
        '提示3': 可配置 maxsize'
      ],
      'explanation': 'functools.lru_cache 使用 LRU 策略来管理缓存条目，适合具有局部性访问模式的函数。',
      'example': '@lru_cache(maxsize=128)\ndef f(x): return x*x'
    },

    {
      'id': 3,
      'type': 'fill',
      'title': '缓存代价（填空）',
      'content': '引入缓存会带来的代价主要包括？',
      'input': '',
      'output': '',
      'code': 'print("内存使用、缓存维护与一致性管理")',
      'options': '',
      'answer': '',
      'explanation': '缓存占用额外内存并可能需要过期/失效策略，以及缓存命中率低时浪费资源。',
      'example': ''
    },

    {
      'id': 4,
      'type': 'choice',
      'title': 'Cache key 设计',
      'content': '为函数缓存设计 key 时，应优先考虑？',
      'options': {
        'A': '可哈希且能唯一标识调用参数',
        'B': '尽量复杂以防碰撞',
        'C': '只用对象 id',
        'D': '随意字符串'
      },
      'answer': 'A',
      'hints': [
        '提示1': key 应该是可哈希的',
        '提示2': 能唯一表示参数组合',
        '提示3': 使用序列化或元组表示参数'
      ],
      'explanation': '缓存 key 必须唯一且可哈希，以确保相同输入命中相同缓存。',
      'example': ''
    },

    {
      'id': 5,
      'type': 'fill',
      'title': '失效策略（填空）',
      'content': '常见的缓存失效策略包括哪些？',
      'input': '',
      'output': '',
      'code': 'print("TTL、LRU、手动清理、写时回收")',
      'options': '',
      'answer': '',
      'explanation': 'TTL（过期时间）、LRU、基于大小的回收或应用触发的清理是常见策略。',
      'example': ''
    },

    {
      'id': 6,
      'type': 'choice',
      'title': '分布式缓存',
      'content': '使用 Redis 等分布式缓存的好处是？',
      'options': {
        'A': '跨进程与跨机器共享缓存',
        'B': '自动提高一致性',
        'C': '永远不需要失效策略',
        'D': '总比本地缓存更快'
      },
      'answer': 'A',
      'hints': [
        '提示1': Redis 可被多个服务实例共享',
        '提示2': 需要考虑网络延迟与可用性',
        '提示3': 适合横向扩展场景'
      ],
      'explanation': '分布式缓存支持多实例共享数据，但需考虑网络开销、序列化与一致性方案。',
      'example': ''
    },

    {
      'id': 7,
      'type': 'choice',
      'title': '缓存穿透',
      'content': '缓存穿透通常指什么问题？',
      'options': {
        'A': '大量请求绕过缓存打到后端，造成压力',
        'B': '缓存被恶意清空',
        'C': '内存泄漏',
        'D': '缓存自动修复'
      },
      'answer': 'A',
      'hints': [
        '提示1': 请求的 key 从未缓存或频繁失效',
        '提示2': 可能因参数多样化导致低命中率',
        '提示3': 可通过布隆过滤器等缓解'
      ],
      'explanation': '缓存穿透指缓存失效或未命中的请求直接到达后端，可能引发压垮后端的问题。',
      'example': ''
    },

    {
      'id': 8,
      'type': 'fill',
      'title': '缓存雪崩（填空）',
      'content': '缓存雪崩是指什么情况？',
      'input': '',
      'output': '',
      'code': 'print("大量缓存同时失效导致后端瞬时洪峰")',
      'options': '',
      'answer': '',
      'explanation': '当大量缓存条目同时过期或被清空，会有大量请求打到后端，造成雪崩效应。',
      'example': ''
    },

    {
      'id': 9,
      'type': 'choice',
      'title': 'Cache Aside 模式',
      'content': 'Cache Aside 模式的关键步骤是？',
      'options': {
        'A': '应用先查缓存，未命中再查数据库并回填缓存',
        'B': '数据库主动推送到缓存',
        'C': '缓存承担主存储',
        'D': '禁用数据库'
      },
      'answer': 'A',
      'hints': [
        '提示1': 先读缓存再落库',
        '提示2': 写操作需同步更新或删除缓存',
        '提示3': 简单且常用'
      ],
      'explanation': 'Cache Aside 模式由应用控制缓存读写，未命中时回源并回填缓存。',
      'example': ''
    },

    {
      'id': 10,
      'type': 'fill',
      'title': '缓存一致性（填空）',
      'content': '对写操作保持缓存一致性的常见策略包括？',
      'input': '',
      'output': '',
      'code': 'print("写入时更新/删除缓存或使用消息通知失效")',
      'options': '',
      'answer': '',
      'explanation': '常见策略有写时更新、写时删除、异步失效通知或短 TTL。',
      'example': ''
    },

    {
      'id': 11,
      'type': 'choice',
      'title': 'memoization 风险',
      'content': '使用 memoization（记忆化）缓存函数结果时需注意？',
      'options': {
        'A': '缓存大小与内存增长，慎重处理可变参数',
        'B': '一定提高性能',
        'C': '能自动管理失效',
        'D': '不适合纯函数'
      },
      'answer': 'A',
      'hints': [
        '提示1': memoization 适合纯函数',
        '提示2': 可变参数不能直接作为 key',
        '提示3': 需考虑缓存清理策略'
      ],
      'explanation': 'memoization 要求 key 设计合理且须控制缓存大小以避免内存问题。',
      'example': ''
    },

    {
      'id': 12,
      'type': 'choice',
      'title': '缓存击穿',
      'content': '缓存击穿通常发生在什么情况下？',
      'options': {
        'A': '热点 key 在缓存失效瞬间大量并发请求同时回源',
        'B': '缓存命中率极高',
        'C': '缓存从未被访问',
        'D': '数据一致'
      },
      'answer': 'A',
      'hints': [
        '提示1': 热点 key 失效会造成短时间洪峰',
        '提示2': 可用互斥锁或单线程回源避免',
        '提示3': 预热或错峰失效可缓解'
      ],
      'explanation': '缓存击穿是热点 key 过期导致短时间大量回源，需用互斥回源或互斥锁防护。',
      'example': ''
    },

    {
      'id': 13,
      'type': 'fill',
      'title': '实践建议（填空）',
      'content': '在引入缓存前应先做什么？',
      'input': '',
      'output': '',
      'code': 'print("识别热点、基准测试并评估一致性需求")',
      'options': '',
      'answer': '',
      'explanation': '在设计缓存前应识别热点、评估一致性需求并通过基准测试验证收益。',
      'example': ''
    },

    {
      'id': 14,
      'type': 'choice',
      'title': '本地缓存 vs 分布式',
      'content': '本地内存缓存相对于分布式缓存的优点是？',
      'options': {
        'A': '访问延迟低、实现简单',
        'B': '可跨实例共享',
        'C': '天然一致性',
        'D': '无限容量'
      },
      'answer': 'A',
      'hints': [
        '提示1': 本地访问速度快',
        '提示2': 受限于单实例内存',
        '提示3': 需处理跨实例一致性'
      ],
      'explanation': '本地缓存提供最低延迟但无法跨实例共享，适合低一致性或单机场景。',
      'example': ''
    },

    {
      'id': 15,
      'type': 'fill',
      'title': '总结（填空）',
      'content': '缓存设计的核心权衡点是？',
      'input': '',
      'output': '',
      'code': 'print("性能、内存与一致性之间的权衡")',
      'options': '',
      'answer': '',
      'explanation': '缓存需在性能提升、内存占用与数据一致性之间做权衡，并设计失效策略。',
      'example': ''
    }

  ]
}

```
