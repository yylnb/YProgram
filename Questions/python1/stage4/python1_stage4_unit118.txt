```plaintext
{
  'unit': '第118单元：多线程与多进程比较',
  'questions': [

    {
      'id': 1,
      'type': 'choice',
      'title': '进程隔离',
      'content': '多进程相比多线程的一个主要优点是？',
      'options': {
        'A': '进程间内存隔离，崩溃互不影响',
        'B': '进程更轻量',
        'C': '无序执行',
        'D': '自动共享内存'
      },
      'answer': 'A',
      'hints': [
        '提示1：进程拥有独立内存空间',
        '提示2': 一个进程崩溃不会直接破坏其它进程',
        '提示3': 进程间通信需显式实现'
      ],
      'explanation': '多进程通过独立地址空间隔离故障，但会带来更高的内存和 IPC 成本。',
      'example': ''
    },

    {
      'id': 2,
      'type': 'choice',
      'title': '通信开销',
      'content': '以下哪项通常导致多进程方案相比多线程更高的开销？',
      'options': {
        'A': '进程间通信（序列化/复制）',
        'B': '线程上下文切换',
        'C': '线程栈大小',
        'D': '全局变量'
      },
      'answer': 'A',
      'hints': [
        '提示1：IPC 需要序列化/复制数据',
        '提示2': 大对象传输成本高',
        '提示3': 共享内存可减轻此问题'
      ],
      'explanation': '进程间通信通常涉及数据序列化与复制，带来较高延迟与内存开销。',
      'example': ''
    },

    {
      'id': 3,
      'type': 'fill',
      'title': '适用场景（填空）',
      'content': '当任务需要在多核上并行运行并避免 GIL 限制，应选择？',
      'input': '',
      'output': '',
      'code': 'print("多进程")',
      'options': '',
      'answer': '',
      'explanation': '多进程能在多核上实现真正并行，适合 CPU 密集任务。',
      'example': ''
    },

    {
      'id': 4,
      'type': 'choice',
      'title': '启动开销',
      'content': '相比创建线程，创建新进程通常如何？',
      'options': {
        'A': '启动开销更大，消耗更多内存',
        'B': '更快',
        'C': '相同',
        'D': '更节省资源'
      },
      'answer': 'A',
      'hints': [
        '提示1：进程需复制或重新加载解释器',
        '提示2': 进程数量多时内存占用显著',
        '提示3': 使用进程池可复用进程'
      ],
      'explanation': '创建进程会启动独立解释器，带来更高的时间和内存开销，进程池能减少频繁创建销毁成本。',
      'example': ''
    },

    {
      'id': 5,
      'type': 'fill',
      'title': '共享数据（填空）',
      'content': '在多线程中共享数据通常比多进程更容易，因为？',
      'input': '',
      'output': '',
      'code': 'print("线程共享同一地址空间")',
      'options': '',
      'answer': '',
      'explanation': '线程共享地址空间，访问共享内存方便但需同步以避免竞态。',
      'example': ''
    },

    {
      'id': 6,
      'type': 'choice',
      'title': '进程池优势',
      'content': '使用进程池（ProcessPoolExecutor）时的优势是？',
      'options': {
        'A': '复用进程减少创建销毁开销',
        'B': '自动共享大对象',
        'C': '不需要序列化',
        'D': '节省内存'
      },
      'answer': 'A',
      'hints': [
        '提示1：进程池预先启动工作进程',
        '提示2': 避免频繁创建进程开销',
        '提示3': 仍需考虑 IPC 成本'
      ],
      'explanation': '进程池通过复用进程降低了频繁创建的成本，但传输数据仍需序列化。',
      'example': ''
    },

    {
      'id': 7,
      'type': 'choice',
      'title': '信号与进程',
      'content': '在多进程程序中使用信号处理需注意？',
      'options': {
        'A': '信号处理通常发生在主进程，子进程行为可能不同',
        'B': '信号会广播到所有进程并相同处理',
        'C': '子进程无法接收信号',
        'D': '信号用于线程间通信'
      },
      'answer': 'A',
      'hints': [
        '提示1：不同平台对信号的处理不同',
        '提示2': 在子进程中需小心注册处理器',
        '提示3': 常在主进程集中管理'
      ],
      'explanation': '信号处理需要谨慎设计，通常在主进程处理并向子进程传达控制信息。',
      'example': ''
    },

    {
      'id': 8,
      'type': 'fill',
      'title': '进程间通信（填空）',
      'content': '常见的 IPC 方式包括哪些？',
      'input': '',
      'output': '',
      'code': 'print("管道、队列、共享内存、sockets、mmap")',
      'options': '',
      'answer': '',
      'explanation': '常见 IPC 机制包含管道、队列、共享内存、socket 与 mmap 等，各有性能与复杂度权衡。',
      'example': ''
    },

    {
      'id': 9,
      'type': 'choice',
      'title': '序列化成本',
      'content': '在进程间传输复杂对象时，主要性能瓶颈通常是？',
      'options': {
        'A': '序列化/反序列化与数据复制',
        'B': '函数调用开销',
        'C': '线程锁竞争',
        'D': '内存不足与 CPU 无关'
      },
      'answer': 'A',
      'hints': [
        '提示1': 'pickle 等序列化库会消耗 CPU',
        '提示2': 大对象复制代价高',
        '提示3': 使用共享内存可减少复制'
      ],
      'explanation': '序列化与拷贝是进程间传输大对象的主要性能开销。',
      'example': ''
    },

    {
      'id': 10,
      'type': 'fill',
      'title': '调试难度（填空）',
      'content': '在并发模型中，通常哪种更容易调试，线程还是进程？',
      'input': '',
      'output': '',
      'code': 'print("进程更易隔离但调试跨进程交互更复杂")',
      'options': '',
      'answer': '',
      'explanation': '线程共享地址空间便于 inspect，但竞态难复现；进程隔离更稳健但跨进程交互复杂。',
      'example': ''
    },

    {
      'id': 11,
      'type': 'choice',
      'title': '混合策略',
      'content': '在复杂应用中常见的并发策略是？',
      'options': {
        'A': '异步 I/O + 进程池/线程池 混合使用',
        'B': '只使用多线程',
        'C': '只使用多进程',
        'D': '禁止并发'
      },
      'answer': 'A',
      'hints': [
        '提示1': '组合不同模型发挥各自优势',
        '提示2': '例如 asyncio 负责 I/O，进程池处理 CPU 任务',
        '提示3': '需关注边界与数据传递'
      ],
      'explanation': '混合方案能兼顾 I/O 并发与 CPU 并行，适合复杂生产环境。',
      'example': ''
    },

    {
      'id': 12,
      'type': 'fill',
      'title': '资源限制（填空）',
      'content': '部署并发程序时应关注的系统级资源包括？',
      'input': '',
      'output': '',
      'code': 'print("CPU、内存、文件描述符、网络带宽")',
      'options': '',
      'answer': '',
      'explanation': '监控并配置 CPU、内存、文件句柄与网络等资源以避免瓶颈或限制。',
      'example': ''
    },

    {
      'id': 13,
      'type': 'choice',
      'title': '序列化格式选择',
      'content': '在进程间频繁传输数据时，选择高效序列化格式的理由是？',
      'options': {
        'A': '减少 CPU 与传输开销',
        'B': '增加可读性',
        'C': '便于手工编辑',
        'D': '降低安全'
      },
      'answer': 'A',
      'hints': [
        '提示1': 二进制格式（msgpack）常比 pickle 高效',
        '提示2': 注意兼容性和安全',
        '提示3': 测试不同方案性能'
      ],
      'explanation': '高效序列化可降低 CPU 负载与传输时间，提升整体吞吐。',
      'example': ''
    },

    {
      'id': 14,
      'type': 'fill',
      'title': '最佳实践（填空）',
      'content': '选择并发模型时首要考虑什么？',
      'input': '',
      'output': '',
      'code': 'print("任务类型（I/O 或 CPU）、资源与可维护性")',
      'options': '',
      'answer': '',
      'explanation': '根据任务特性（I/O/CPU）、可用资源与复杂度权衡并发策略。',
      'example': ''
    },

    {
      'id': 15,
      'type': 'fill',
      'title': '总结（填空）',
      'content': '多线程与多进程各自的权衡要点是？',
      'input': '',
      'output': '',
      'code': 'print("线程轻量共享但受 GIL；进程隔离并行但开销大")',
      'options': '',
      'answer': '',
      'explanation': '线程适合 I/O 密集且共享数据；进程适合并行 CPU 密集任务，但需考虑 IPC 与内存。',
      'example': ''
    }

  ]
}

```
