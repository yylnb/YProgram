```plaintext
{
  'unit': '第114单元：列表推导与性能陷阱',
  'questions': [

    {
      'id': 1,
      'type': 'choice',
      'title': '列表推导的好处',
      'content': '相比显式循环，列表推导通常具有什么优点？',
      'options': {
        'A': '更简洁且通常更快（由 C 实现的内部循环）',
        'B': '使用更少内存',
        'C': '支持并行执行',
        'D': '自动排序'
      },
      'answer': 'A',
      'hints': [
        '提示1：列表推导在 C 层面完成循环和附加',
        '提示2': 更少的 Python 层函数调用开销',
        '提示3': 可读性更高'
      ],
      'explanation': '列表推导在内部优化循环和元素添加，一般比等价的 Python 循环更快。',
      'example': 'squares = [x*x for x in range(1000)]'
    },

    {
      'id': 2,
      'type': 'choice',
      'title': '推导与生成器',
      'content': '当数据量很大且不需要保存全部结果时，更适合使用？',
      'options': {
        'A': '生成器表达式',
        'B': '列表推导',
        'C': '集合推导',
        'D': '三元表达式'
      },
      'answer': 'A',
      'hints': [
        '提示1：生成器惰性产出',
        '提示2': 列表推导会占用内存存储所有元素',
        '提示3': 适合流式处理'
      ],
      'explanation': '生成器表达式按需生成元素，适合节省内存。',
      'example': '(x for x in big_iter)'
    },

    {
      'id': 3,
      'type': 'fill',
      'title': '嵌套推导复杂度（填空）',
      'content': '嵌套列表推导的时间复杂度通常如何计算？',
      'input': '',
      'output': '',
      'code': 'print("乘积级别，例如 O(n*m)")',
      'options': '',
      'answer': '',
      'explanation': '嵌套循环会产生乘积级别的复杂度，取决于各层循环大小。',
      'example': ''
    },

    {
      'id': 4,
      'type': 'choice',
      'title': '避免副作用',
      'content': '在列表推导中不推荐做什么？',
      'options': {
        'A': '在推导体中产生副作用（如写文件或修改外部状态）',
        'B': '做纯计算',
        'C': '使用条件过滤',
        'D': '简单表达式'
      },
      'answer': 'A',
      'hints': [
        '提示1：推导应保持表达式式的纯粹性',
        '提示2': 副作用会降低可读性和可测试性',
        '提示3': 副作用最好放在显式循环中'
      ],
      'explanation': '列表推导用于构造序列，不应在内部执行影响外部状态的副作用。',
      'example': ''
    },

    {
      'id': 5,
      'type': 'fill',
      'title': '推导与内存（填空）',
      'content': '若需要生成但不保存大量结果，应使用？',
      'input': '',
      'output': '',
      'code': 'print("生成器表达式或迭代器")',
      'options': '',
      'answer': '',
      'explanation': '生成器表达式或迭代器可避免同时保留大量数据。',
      'example': ''
    },

    {
      'id': 6,
      'type': 'choice',
      'title': '多条件过滤',
      'content': '在推导中使用多个条件过滤会如何影响性能？',
      'options': {
        'A': '每个条件都会增加判断成本，但通常仍为线性遍历',
        'B': '变为指数级',
        'C': '忽略后续条件',
        'D': '自动并行'
      },
      'answer': 'A',
      'hints': [
        '提示1：条件越多每个元素判断成本越高',
        '提示2': 遍历仍然线性',
        '提示3': 可通过提前过滤减少成本'
      ],
      'explanation': '多个过滤条件会增加每元素的常数判断开销，但总体仍按元素线性执行。',
      'example': ''
    },

    {
      'id': 7,
      'type': 'choice',
      'title': '构造大型列表',
      'content': '若需要构建非常大的列表并随后多次访问，最佳做法是？',
      'options': {
        'A': '直接创建列表并复用',
        'B': '每次重新生成',
        'C': '使用生成器并每次遍历生成',
        'D': '使用 set'
      },
      'answer': 'A',
      'hints': [
        '提示1：如果多次访问，预先创建并保存避免重复计算',
        '提示2': 考虑内存与访问频率权衡',
        '提示3': 可能使用缓存'
      ],
      'explanation': '若需要重复访问，先生成并保留列表可避免重复计算，但需考虑内存成本。',
      'example': ''
    },

    {
      'id': 8,
      'type': 'fill',
      'title': '推导与函数调用（填空）',
      'content': '在推导中频繁调用开销大的函数会使性能如何？',
      'input': '',
      'output': '',
      'code': 'print("显著下降")',
      'options': '',
      'answer': '',
      'explanation': '每次迭代调用昂贵函数会显著增加总体耗时，考虑缓存或提前计算。',
      'example': ''
    },

    {
      'id': 9,
      'type': 'choice',
      'title': '避免重复计算',
      'content': '在推导中若某子表达式重复计算，如何优化？',
      'options': {
        'A': '在 comprehension 之前计算并重用',
        'B': '无法优化',
        'C': '使用全局变量',
        'D': '增加条件'
      },
      'answer': 'A',
      'hints': [
        '提示1：将常量或不变结果提取到外部',
        '提示2': 减少每次迭代的工作量',
        '提示3': 提高性能'
      ],
      'explanation': '将不变或可缓存的子表达式移出推导体可以减少重复计算开销。',
      'example': ''
    },

    {
      'id': 10,
      'type': 'fill',
      'title': '推导返回类型（填空）',
      'content': '列表推导、集合推导和字典推导分别返回什么类型？',
      'input': '',
      'output': '',
      'code': 'print("list, set, dict")',
      'options': '',
      'answer': '',
      'explanation': '语法不同会产生对应类型：[]=>list, {} with one expr=>set or dict 取决于键值对',
      'example': ''
    },

    {
      'id': 11,
      'type': 'choice',
      'title': '可读性权衡',
      'content': '复杂的嵌套推导是否推荐？',
      'options': {
        'A': '不推荐，影响可读性，考虑显式循环',
        'B': '一律推荐',
        'C': '性能总是更好',
        'D': '编译器会自动简化'
      },
      'answer': 'A',
      'hints': [
        '提示1：可读性优先于少量性能提升',
        '提示2': 复杂逻辑应拆分',
        '提示3': 便于测试'
      ],
      'explanation': '深度嵌套的推导可读性差，应用显式循环或拆分步骤提高可维护性。',
      'example': ''
    },

    {
      'id': 12,
      'type': 'choice',
      'title': '推导与局部变量',
      'content': '列表推导中的变量作用域如何影响性能？',
      'options': {
        'A': '局部变量访问快于全局，适当将函数或常量作为局部引用',
        'B': '全局更快',
        'C': '无差别',
        'D': '推导不允许局部变量'
      },
      'answer': 'A',
      'hints': [
        '提示1：局部变量查找更快',
        '提示2': 可以通过绑定函数或常量到局部提高效率',
        '提示3': 小幅优化'
      ],
      'explanation': '在推导中使用局部变量（或把全局绑定为局部）能略微提升性能。',
      'example': ''
    },

    {
      'id': 13,
      'type': 'fill',
      'title': '内存峰值（填空）',
      'content': '一次性创建巨大列表会产生什么问题？',
      'input': '',
      'output': '',
      'code': 'print("高内存峰值，可能导致 OOM")',
      'options': '',
      'answer': '',
      'explanation': '一次性分配大量内存可能导致内存峰值过高并引发内存不足。',
      'example': ''
    },

    {
      'id': 14,
      'type': 'choice',
      'title': '何时优先可读性',
      'content': '在追求性能时何时应优先选择更可读的写法？',
      'options': {
        'A': '当性能差异微小且影响维护时',
        'B': '永远不考虑可读性',
        'C': '始终牺牲可读性换取性能',
        'D': '仅在脚本中考虑'
      },
      'answer': 'A',
      'hints': [
        '提示1：权衡维护成本和性能',
        '提示2': 先衡量再优化',
        '提示3': 使用基准测试验证'
      ],
      'explanation': '在多数工程场景下，可读性与维护性应优先，只有在确有性能瓶颈时再优化。',
      'example': ''
    },

    {
      'id': 15,
      'type': 'fill',
      'title': '总结（填空）',
      'content': '列表推导主要优点是？',
      'input': '',
      'output': '',
      'code': 'print("简洁且通常更快")',
      'options': '',
      'answer': '',
      'explanation': '推导简洁、在 C 层优化循环，通常比纯 Python 循环更快。',
      'example': ''
    }

  ]
}

```
