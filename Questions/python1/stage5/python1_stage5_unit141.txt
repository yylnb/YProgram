```plaintext
{
  'unit': '第141单元：数据库与 SQLite 入门',
  'questions': [

    {
      'id': 1,
      'type': 'choice',
      'title': 'SQLite 的特点',
      'content': '关于 SQLite，下列哪项描述更准确？',
      'options': {
        'A': '轻量级的嵌入式数据库，适合单进程应用',
        'B': '分布式数据库，适合集群部署',
        'C': '只能用于内存数据库',
        'D': '需要独立服务器进程'
      },
      'answer': 'A',
      'hints': [
        '提示1：SQLite 是文件型数据库',
        '提示2：无需单独服务进程',
        '提示3：适合小型项目和测试'
      ],
      'explanation': 'SQLite 是嵌入式、文件型数据库，适合单进程或小型应用。',
      'example': 'import sqlite3\nconn = sqlite3.connect("db.sqlite")'
    },

    {
      'id': 2,
      'type': 'choice',
      'title': '连接与游标',
      'content': '在使用 sqlite3 时，通常通过哪个对象执行 SQL？',
      'options': {
        'A': 'cursor',
        'B': 'engine',
        'C': 'session',
        'D': 'connector'
      },
      'answer': 'A',
      'hints': ['提示1：先 conn.cursor()', '提示2：cursor.execute 执行 SQL', '提示3：fetchone/fetchall 获取结果'],
      'explanation': '使用 conn.cursor() 获取游标，通过 cursor.execute 执行 SQL。',
      'example': 'c = conn.cursor()\nc.execute("SELECT 1")\nprint(c.fetchone())'
    },

    {
      'id': 3,
      'type': 'choice',
      'title': '参数化查询',
      'content': '为了避免 SQL 注入，应使用哪种方式传递参数？',
      'options': {
        'A': '参数化查询（占位符和参数）',
        'B': '字符串拼接',
        'C': '格式化 SQL 文件',
        'D': '动态 eval'
      },
      'answer': 'A',
      'hints': ['提示1：不要直接拼接用户输入', '提示2：sqlite3 支持 ? 占位符', '提示3：参数化可自动转义'],
      'explanation': '使用参数化查询可以防止注入并正确转换参数类型。',
      'example': 'c.execute("SELECT * FROM t WHERE id=?", (id_val,))'
    },

    {
      'id': 4,
      'type': 'fill',
      'title': '提交事务（填空）',
      'content': '对数据库修改后需要调用 __1__ 提交事务以保存更改。',
      'input': '',
      'output': '',
      'code': 'conn = sqlite3.connect("db.sqlite")\nc = conn.cursor()\nc.execute("INSERT INTO t VALUES (1)")\n__1__',
      'options': 'conn.commit(), conn.close(), c.commit(), conn.rollback()',
      'answer': '1',
      'explanation': 'conn.commit() 用于提交事务，保存对数据库的修改。',
      'example': ''
    },

    {
      'id': 5,
      'type': 'fill',
      'title': '关闭连接（填空）',
      'content': '完成数据库操作后应调用 __1__ 释放资源。',
      'input': '',
      'output': '',
      'code': 'conn = sqlite3.connect("db.sqlite")\n# ...\n__1__',
      'options': 'conn.close(), conn.commit(), c.close(), del conn',
      'answer': '1',
      'explanation': 'conn.close() 用于关闭连接并释放资源。',
      'example': ''
    },

    {
      'id': 6,
      'type': 'choice',
      'title': '事务回滚',
      'content': '当执行 SQL 过程中出现异常时，为了回退更改应调用？',
      'options': {'A': 'conn.rollback()', 'B': 'conn.commit()', 'C': 'conn.close()', 'D': 'raise'},
      'answer': 'A',
      'hints': ['提示1：rollback 恢复到上次提交状态', '提示2：通常在 except 块中调用', '提示3：避免部分提交导致不一致'],
      'explanation': 'conn.rollback() 用于回滚事务以撤销未提交的更改。',
      'example': ''
    },

    {
      'id': 7,
      'type': 'choice',
      'title': 'schema 定义',
      'content': '创建表结构通常使用哪个 SQL 语句？',
      'options': {'A': 'CREATE TABLE', 'B': 'INSERT INTO', 'C': 'UPDATE', 'D': 'SELECT'},
      'answer': 'A',
      'hints': ['提示1：CREATE TABLE 定义列与类型', '提示2：首次建立数据库需要建表', '提示3：可添加 PRIMARY KEY'],
      'explanation': '使用 CREATE TABLE 来定义表和列的结构。',
      'example': 'CREATE TABLE users(id INTEGER PRIMARY KEY, name TEXT)'
    },

    {
      'id': 8,
      'type': 'choice',
      'title': 'SQLite 类型系统',
      'content': 'SQLite 的列类型系统最显著的特点是？',
      'options': {'A': '类型亲和性（type affinity）较宽松', 'B': '强类型严格匹配', 'C': '不支持字符串', 'D': '仅支持二进制'},
      'answer': 'A',
      'hints': ['提示1：可将任意类型写入列', '提示2：SQLite 会尝试做类型转换', '提示3：适合快速开发'],
      'explanation': 'SQLite 使用类型亲和性模型，类型约束比关系型数据库宽松。',
      'example': ''
    },

    {
      'id': 9,
      'type': 'fill',
      'title': '参数占位符（填空）',
      'content': 'sqlite3 模块中参数占位符通常使用字符 __1__。',
      'input': '',
      'output': '',
      'code': 'c.execute("SELECT * FROM t WHERE id=__1__", (1,))',
      'options': '? , %s , :1 , {}',
      'answer': '1',
      'explanation': 'sqlite3 使用 ? 占位符来参数化查询。',
      'example': ''
    },

    {
      'id': 10,
      'type': 'fill',
      'title': '行游标读取（填空）',
      'content': '执行查询后使用 cursor.__1__() 获取所有行。',
      'input': '',
      'output': '',
      'code': 'c.execute("SELECT * FROM t")\nrows = c.__1__()',
      'options': 'fetchall, fetchone, fetchmany, read',
      'answer': '1',
      'explanation': 'fetchall 返回所有结果行的列表。',
      'example': ''
    },

    {
      'id': 11,
      'type': 'choice',
      'title': '持久化存储',
      'content': 'SQLite 数据库文件通常存放在哪里？',
      'options': {'A': '磁盘文件', 'B': '仅内存', 'C': '远程服务器', 'D': '浏览器本地存储'},
      'answer': 'A',
      'hints': ['提示1：通过文件路径连接', '提示2：可为 ":memory:" 使用内存数据库', '提示3：文件易于备份'],
      'explanation': 'SQLite 使用磁盘文件来持久化数据，或通过特殊路径使用内存数据库。',
      'example': ''
    },

    {
      'id': 12,
      'type': 'choice',
      'title': '并发写入限制',
      'content': 'SQLite 在高并发写入场景下一般会如何表现？',
      'options': {'A': '写操作会被串行化，可能成为瓶颈', 'B': '写入自动分片', 'C': '无限并发写入', 'D': '拒绝写入'},
      'answer': 'A',
      'hints': ['提示1：SQLite 在写锁时串行化写操作', '提示2：适合读多写少场景', '提示3：可通过 WAL 提高并发读写'],
      'explanation': 'SQLite 在写操作上会串行化，适合读多写少的用例。',
      'example': ''
    },

    {
      'id': 13,
      'type': 'fill',
      'title': '内存数据库（填空）',
      'content': '创建内存 SQLite 数据库可使用连接字符串 "__1__"。',
      'input': '',
      'output': '',
      'code': 'conn = sqlite3.connect("__1__")',
      'options': ':memory:, memory:, /tmp/db, memory',
      'answer': '1',
      'explanation': '使用 ":memory:" 可创建仅内存的 SQLite 数据库实例。',
      'example': ''
    },

    {
      'id': 14,
      'type': 'fill',
      'title': '备份数据库（填空）',
      'content': '要制作 SQLite 数据库的在线备份，可使用 connection.__1__() API（或 sqlite3 的 backup 方法）。',
      'input': '',
      'output': '',
      'code': '',
      'options': 'backup, copy, dump, export',
      'answer': '1',
      'explanation': 'sqlite3 提供 backup 方法来增量或完整备份数据库。',
      'example': ''
    },

    {
      'id': 15,
      'type': 'fill',
      'title': '总结（填空）',
      'content': 'SQLite 适合 __1__ 场景，但在高并发写场景应考虑 __2__。',
      'input': '',
      'output': '',
      'code': '',
      'options': '嵌入式/轻量, 分布式数据库, 高吞吐, 实时流处理',
      'answer': '1,2',
      'explanation': 'SQLite 适合嵌入式或轻量场景；高并发写场景可考虑服务器型数据库或分片方案。',
      'example': ''
    }

  ]
}

```
